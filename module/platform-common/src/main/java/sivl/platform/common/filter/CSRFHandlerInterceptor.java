package sivl.platform.common.filter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import sivl.platform.common.constant.Constant;import sivl.platform.common.constant.ErrorCode;import sivl.platform.common.model.NetLogModel;import sivl.platform.common.service.SysParamService;import sivl.platform.common.utils.HttpClientUtils;import sivl.platform.common.utils.JSONUtil;import sivl.platform.common.utils.LogUtil;import sivl.platform.common.utils.StringUtil;/** * CSRF来源拦截 * @author lixuefeng * @createTime 2015年12月2日 * @version 1.0 */public class CSRFHandlerInterceptor extends HandlerInterceptorAdapter {	private static String className = "sivl.platform.common.filter.CSRFHandlerInterceptor";		@Autowired	private SysParamService sysParamService;		@Override	public boolean preHandle(HttpServletRequest request,			HttpServletResponse response, Object handler) throws Exception {		//请求uri		String url = request.getRequestURI();		String needFilterUrls = sysParamService.getValue(Constant.CSRF_FILTER_URL.getKey());		String[] needFilterUrl = needFilterUrls.split("\\|");		boolean doFilter = isDoFilter(needFilterUrl, url);		if(doFilter){			//对请求参数进行CSRF校验			String source = request.getHeader("referer");//请求来源			String remoteIp = HttpClientUtils.getRemoteAddr(request);			//对请求参数进行token校验			String returnFmt = HttpClientUtils.getRequestFormat(request);//数据返回格式			if(StringUtil.isEmpty(source) && StringUtil.isEmpty(remoteIp)){				HttpClientUtils.handErrorResponse(request, response, returnFmt, "请放弃攻击！谢谢！",ErrorCode.error404);				LogUtil.netCSRFLog(JSONUtil.obj2json(new NetLogModel(request).buildClassName(className).buildInterfaceName(request.getRequestURI()).buildMsg("CSRF攻击")), CSRFHandlerInterceptor.class);				return false;			}			if(StringUtil.isEmpty(source)) source = remoteIp;			//检查来源是否合法			if(!isLegalSource(source)){				HttpClientUtils.handErrorResponse(request, response, returnFmt, "请放弃攻击！谢谢！",ErrorCode.error404);				LogUtil.netCSRFLog(JSONUtil.obj2json(new NetLogModel(request).buildClassName(className).buildInterfaceName(request.getRequestURI()).buildMsg("CSRF攻击")), CSRFHandlerInterceptor.class);				return false;			}			return true;		}		return super.preHandle(request, response, handler);	}		/**	 * 需要进行过滤	 * @param needFilter	 * @param url	 * @return boolean	 */	public boolean isDoFilter(String[] needFilter ,String url){		//不需要进行过滤校验		boolean result = false;		for(String filter : needFilter){			if(url.indexOf(filter) != -1){				//需要进行过滤校验				return true;			}		}		return result;	}		/**	 * 判断请求来源是否合法	 * @param referer	 * @return boolean	 */	public boolean isLegalSource(String referer){		//不合法		boolean result = false;		//校验域名集合		String[] domains = sysParamService.getValue(Constant.CSRF_FILTER_VALUE.getKey()).split("\\|");		for(String domian : domains){			if(domian.indexOf(referer) != -1){				//需要进行过滤校验				return true;			}		}		return result;	}}