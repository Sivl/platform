package sivl.platform.common.encrypt;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.Charsets;import org.apache.commons.codec.binary.Base64;import org.apache.commons.codec.binary.StringUtils;import sivl.platform.common.constant.Constant;import sivl.platform.common.utils.StringUtil;/** * 加密工具<br/> * 目的：提供各种加密 * @author lixuefeng * @createTime 2015年11月28日 * @version 1.0 */public class Encrypt {		private static final String Algorithm = "DESede"; //定义 加密算法,可用 DES,DESede,Blowfish	//加密密钥	private static final String appKey = "yatang.usercenter.encrypt.key.addby.sivl";	private static byte[] _appKey = null;		/**	 * base64加密	 * 目的：	 * @author lixuefeng	 * @date 2016年1月14日	 * @param data	 * @return	 */	public static byte[] base64Encrypt(String data){		return Base64.encodeBase64(data.getBytes());	}		/**     * byte2Base64     * @author lixuefeng     * @creatTime 2016年1月19日 下午3:39:45     * @version 1.0     * @param b     * @return     */    public static String base64EncryptString(byte[] b) {     	return new String(Base64.encodeBase64(b),Charsets.UTF_8);    } 		/**	 * base64解密	 * 目的：	 * @author lixuefeng	 * @date 2016年1月14日	 * @param data	 * @return	 */	public static String base64Decode(byte[] data){		return new String(Base64.decodeBase64(data),Charsets.UTF_8);	}		/**	 * 进行md5加密<br/>	 * 返回2进制加密数据  null:加密失败	 * @param data	 * @return byte[] 	 */	public static byte[] MD5(String data){		if(null == data){			return null;		}		byte[] md5Data = null;		try {			MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = md.digest();		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * 进行md5 32位加密<br/>	 * null:加密失败	 * @param data	 * @return String 	 */	public static String MD532String(String data){		if(null == data){			return null;		}		String md5Data = null;		try {						MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = Encrypt.md5ByteCovString(false, md.digest());		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * 进行md5 16位加密<br/>	 * null:加密失败	 * @param data	 * @return String 	 */	public static String MD516String(String data){		if(null == data){			return null;		}		String md5Data = null;		try {			MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = Encrypt.md5ByteCovString(false, md.digest());		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * md5 bytes 转 string	 * @param is32 是否转为32位	 * @param bytes	 * @return	 */	private static String md5ByteCovString(boolean is32,byte[] bytes){		StringBuffer buf = new StringBuffer("");  		int i ;        for (int offset = 0; offset < bytes.length; offset++) {              i = bytes[offset];              if (i < 0)                  i += 256;              if (i < 16)                  buf.append("0");              buf.append(Integer.toHexString(i));         }          if(!is32){        	// 16位的加密              return buf.toString().substring(8, 24);         }        //32位加密          return buf.toString();	}		/**     * 密码加密算法     * @author lixuefeng     * @creatTime 2016年1月19日 下午3:29:35     * @version 1.0     * @param inStr     * @return     */    public static String YLPWDEncrypt(String inStr){    	//取得24位密钥    	if(null == _appKey){    		_appKey = Encrypt.getAppKey(appKey);;    	}    	//生成密钥        SecretKey deskey = new SecretKeySpec(_appKey, Algorithm);        try {        	Cipher cp = Cipher.getInstance(Algorithm);  			cp.init(Cipher.ENCRYPT_MODE, deskey);  			byte[] byteResul = cp.doFinal(inStr.getBytes());			return base64EncryptString(byteResul);		} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IllegalBlockSizeException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (BadPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}    	return null;    }        /**     * 煜隆密码解密算法     * @author lixuefeng     * @creatTime 2016年1月19日 下午3:30:31     * @version 1.0     * @param inStr     * @return     */    public static String YLPWDDecode(String inStr){    	//取得24位密钥    	if(null == _appKey){    		_appKey = Encrypt.getAppKey(appKey);    	}    	//生成密钥        SecretKey deskey = new SecretKeySpec(_appKey, Algorithm);        //16进制转2进制        byte[] src = Base64.decodeBase64(inStr.getBytes());        try {			Cipher cp = Cipher.getInstance(Algorithm);  			cp.init(Cipher.DECRYPT_MODE, deskey);  			byte[] result = cp.doFinal(src);			return new String(result,Charsets.UTF_8);		} catch (InvalidKeyException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchAlgorithmException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (NoSuchPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IllegalBlockSizeException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (BadPaddingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}    	return null;    }        /**     * 转换成十六进制字符串         * @author lixuefeng     * @creatTime 2016年1月19日 下午3:39:36     * @version 1.0     * @param b     * @return     */    public static String byte2hex(byte[] b) {          String hs = "";          String stmp = "";          for (int n = 0; n < b.length; n++) {              stmp = (java.lang.Integer.toHexString(b[n] & 0XFF));              if (stmp.length() == 1)                  hs = hs + "0" + stmp;              else                  hs = hs + stmp;              if (n < b.length - 1)                  hs = hs + ":";          }          return hs.toUpperCase();      }        /**     * 取得appKey     * @author lixuefeng     * @creatTime 2016年1月19日 下午3:51:45     * @version 1.0     * @param appKey     * @return     */    public static byte[] getAppKey(String appKey){    	try {			MessageDigest md5 = MessageDigest.getInstance("MD5");			md5.update(appKey.getBytes());  	        byte[] bkey = md5.digest();	        int start = bkey.length;	        byte[] bkey24 = new byte[24];  	        for (int i = 0; i < start; i++) {  	            bkey24[i] = bkey[i];  	        }	        for (int i = start; i < 24; i++) {//为了与.net16位key兼容  	            bkey24[i] = bkey[i - start];  	        }	        return bkey24;		} catch (NoSuchAlgorithmException e) {					}     	return null;    }        public static void main(String[] args) {    	String test = "携程";    	String ec = Encrypt.YLPWDEncrypt(test);    	System.out.println(ec);    	System.out.println(Encrypt.YLPWDDecode("1v+uxDlRf1aNOfrTK4cb/iXY1Oy6b+pe"));	}        /**     * 组装密码     * @author lixuefeng     * @creatTime 2016年1月19日 下午4:55:37     * @version 1.0     * @param userName     * @param pwd     * @return     */    public static String assemPwd(String userName,String pwd){    	String userNameEncry = Encrypt.MD532String(userName);    	if(StringUtil.isEmpty(userNameEncry)){    		return null;    	}    	return userNameEncry+pwd;    }        /**     * 拆解密码     * @author lixuefeng     * @creatTime 2016年1月25日 下午3:45:16     * @version 1.0     * @param pwd     * @return     */    public static String disAssemPwd(String pwd){    	String pwdTemp = pwd.substring(32, pwd.length());    	return pwdTemp;    }}