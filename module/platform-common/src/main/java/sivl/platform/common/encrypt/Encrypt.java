package sivl.platform.common.encrypt;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import sivl.platform.common.constant.Constant;/** * 加密工具<br/> * 目的：提供各种加密 * @author lixuefeng * @createTime 2015年11月28日 * @version 1.0 */public class Encrypt {		/**	 * 进行md5加密<br/>	 * 返回2进制加密数据  null:加密失败	 * @param data	 * @return byte[] 	 */	public static byte[] MD5(String data){		if(null == data){			return null;		}		byte[] md5Data = null;		try {						MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = md.digest();		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * 进行md5 32位加密<br/>	 * null:加密失败	 * @param data	 * @return String 	 */	public static String MD532String(String data){		if(null == data){			return null;		}		String md5Data = null;		try {						MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = Encrypt.md5ByteCovString(false, md.digest());		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * 进行md5 16位加密<br/>	 * null:加密失败	 * @param data	 * @return String 	 */	public static String MD516String(String data){		if(null == data){			return null;		}		String md5Data = null;		try {			MessageDigest md = MessageDigest.getInstance("MD5");			md.update(data.getBytes(Constant.UTF8.getValue()));			md5Data = Encrypt.md5ByteCovString(false, md.digest());		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		return md5Data;	}		/**	 * md5 bytes 转 string	 * @param is32 是否转为32位	 * @param bytes	 * @return	 */	private static String md5ByteCovString(boolean is32,byte[] bytes){		StringBuffer buf = new StringBuffer("");  		int i ;        for (int offset = 0; offset < bytes.length; offset++) {              i = bytes[offset];              if (i < 0)                  i += 256;              if (i < 16)                  buf.append("0");              buf.append(Integer.toHexString(i));         }          if(!is32){        	// 16位的加密              return buf.toString().substring(8, 24);         }        //32位加密          return buf.toString();	}}